import { f as CheckResult, c as SetupPaymentResult, Q as QueryResult, A as AttachParams, C as CancelParams, b as CancelResult, e as CheckParams, T as TrackParams, a as TrackResult, O as OpenBillingPortalParams } from './clientAttachTypes-BEgqHiPe.js';
import { C as CheckoutResult, a as CreateReferralCodeResult, R as RedeemReferralCodeResult, A as AttachResult, b as CreateEntityParams, G as GetEntityParams } from './clientEntTypes-Bsi7ciUF.js';
import { A as AutumnPromise, R as Result } from './response-CLgEplsF.js';
import { C as CustomerData, b as CreateCustomerParams, a as Customer, B as BillingPortalResult } from './cusTypes-B-rJwpui.js';
import { E as Entity, D as DeleteEntityResult } from './entTypes-DjKFS-Zk.js';
import { A as AutumnError } from './error-DHbclCVh.js';
import { P as Product } from './prodTypes-B_VMILpU.js';
import 'zod/v4';

interface AutumnClientConfig {
    backendUrl?: string;
    getBearerToken?: () => Promise<string | null | undefined>;
    customerData?: CustomerData;
    includeCredentials?: boolean;
    betterAuthUrl?: string;
    headers?: Record<string, string>;
    pathPrefix?: string;
    defaultReturnUrl?: string;
}
interface IAutumnClient {
    readonly backendUrl?: string;
    readonly prefix: string;
    readonly headers?: Record<string, string>;
    readonly customerData?: CustomerData;
    createCustomer(params: Omit<CreateCustomerParams, "id" | "data"> & {
        errorOnNotFound?: boolean;
    }): Promise<any>;
    detectCors(): Promise<{
        valid: boolean;
        includeCredentials: boolean | undefined;
    }>;
    shouldIncludeCredentials(): Promise<boolean>;
    getHeaders(): Promise<Record<string, string>>;
    handleFetch(options: {
        path: string;
        method: string;
        body?: any;
    }): Promise<any>;
    post(path: string, body: any): Promise<any>;
    get(path: string): Promise<any>;
    delete(path: string): Promise<any>;
    attach(args: any): Promise<any>;
    checkout(args: any): Promise<any>;
    cancel(args: any): Promise<any>;
    check(args: any): Promise<any>;
    track(args: any): Promise<any>;
    openBillingPortal(args: any): Promise<any>;
    setupPayment(args: any): Promise<any>;
    query(args: any): Promise<any>;
    entities: {
        create(args: any): Promise<any>;
        get(entityId: string, args: any): Promise<any>;
        delete(args: any): Promise<any>;
    };
    referrals: {
        createCode(args: any): Promise<any>;
        redeemCode(args: any): Promise<any>;
    };
    products: {
        list(): AutumnPromise<{
            list: Product[];
        }>;
    };
}
declare class AutumnClient implements IAutumnClient {
    readonly backendUrl?: string;
    protected readonly getBearerToken?: () => Promise<string | null | undefined>;
    readonly customerData?: CustomerData;
    protected includeCredentials?: boolean;
    readonly prefix: string;
    readonly camelCase: boolean;
    readonly headers?: Record<string, string>;
    readonly framework?: string;
    readonly defaultReturnUrl?: string;
    constructor({ backendUrl, getBearerToken, customerData, includeCredentials, betterAuthUrl, headers, pathPrefix, defaultReturnUrl, }: AutumnClientConfig);
    /**
     * Detects if the backend supports CORS credentials by making an OPTIONS request
     */
    detectCors(): Promise<{
        valid: boolean;
        includeCredentials: boolean;
    } | {
        valid: boolean;
        includeCredentials: undefined;
    }>;
    /**
     * Automatically determines whether to include credentials based on CORS detection
     */
    shouldIncludeCredentials(): Promise<boolean>;
    getHeaders(): Promise<Record<string, string>>;
    handleFetch({ path, method, body, }: {
        path: string;
        method: string;
        body?: Record<string, unknown> | Record<string, unknown>[];
    }): Promise<Result<any, AutumnError>>;
    post(path: string, body: Record<string, unknown> | Record<string, unknown>[]): Promise<Result<any, AutumnError>>;
    get(path: string): Promise<Result<any, AutumnError>>;
    delete(path: string): Promise<Result<any, AutumnError>>;
    createCustomer(params: Omit<CreateCustomerParams, "id" | "data"> & {
        errorOnNotFound?: boolean;
    }): Promise<Result<Customer, AutumnError>>;
    attach: (params: {
        productId?: string | undefined;
        entityId?: string | undefined;
        options?: {
            featureId: string;
            quantity: number;
        }[] | undefined;
        productIds?: string[] | undefined;
        freeTrial?: boolean | undefined;
        successUrl?: string | undefined;
        metadata?: Record<string, string> | undefined;
        forceCheckout?: boolean | undefined;
        dialog?: any;
        entityData?: any;
        openInNewTab?: boolean | undefined;
        reward?: string | undefined;
        checkoutSessionParams?: Record<string, any> | undefined;
    }) => AutumnPromise<{
        customer_id: string;
        product_ids: string[];
        code: string;
        message: string;
        checkout_url?: string | undefined;
        customer_data?: any;
        invoice?: {
            status: string;
            stripe_id: string;
            hosted_invoice_url: string | null;
            total: number;
            currency: string;
        } | undefined;
    }>;
    checkout: (params: {
        productId?: string | undefined;
        productIds?: string[] | undefined;
        entityId?: string | undefined;
        entityData?: any;
        options?: {
            featureId: string;
            quantity: number;
        }[] | undefined;
        successUrl?: string | undefined;
        openInNewTab?: boolean | undefined;
        dialog?: any;
        forceCheckout?: boolean | undefined;
        freeTrial?: boolean | undefined;
        checkoutSessionParams?: Record<string, any> | undefined;
        reward?: string | undefined;
    }) => AutumnPromise<CheckoutResult>;
    cancel: (params: {
        productId: string;
        entityId?: string | undefined;
        cancelImmediately?: boolean | undefined;
    }) => AutumnPromise<{
        success: boolean;
        customer_id: string;
        product_id: string;
    }>;
    check: (params: {
        featureId?: string | undefined;
        productId?: string | undefined;
        entityId?: string | undefined;
        requiredBalance?: number | undefined;
        sendEvent?: boolean | undefined;
        withPreview?: boolean | undefined;
        dialog?: any;
        entityData?: any;
        properties?: Record<string, any> | undefined;
    }) => AutumnPromise<CheckResult>;
    track: (params: {
        featureId?: string | undefined;
        eventName?: string | undefined;
        entityId?: string | undefined;
        value?: number | undefined;
        idempotencyKey?: string | undefined;
        entityData?: any;
    }) => AutumnPromise<{
        id: string;
        code: string;
        customer_id: string;
        feature_id?: string | undefined;
        event_name?: string | undefined;
    }>;
    openBillingPortal: (params?: {
        returnUrl?: string | undefined;
        openInNewTab?: boolean | undefined;
    } | undefined) => AutumnPromise<BillingPortalResult>;
    setupPayment: (params: {
        successUrl?: string | undefined;
        checkoutSessionParams?: Record<string, any> | undefined;
        openInNewTab?: boolean | undefined;
    }) => AutumnPromise<SetupPaymentResult>;
    query: (params: {
        featureId: string | string[];
        range?: "24h" | "7d" | "30d" | "90d" | "last_cycle" | undefined;
    }) => AutumnPromise<QueryResult>;
    entities: {
        create: (params: {
            id: string;
            featureId: string;
            name?: string | undefined;
        } | {
            id: string;
            featureId: string;
            name?: string | undefined;
        }[]) => AutumnPromise<Entity | Entity[]>;
        get: (entityId: string, params?: {
            expand?: string[] | undefined;
        } | undefined) => AutumnPromise<Entity>;
        delete: (entityId: string) => AutumnPromise<DeleteEntityResult>;
    };
    referrals: {
        createCode: (params: {
            programId: string;
        }) => AutumnPromise<CreateReferralCodeResult>;
        redeemCode: (params: {
            code: string;
        }) => AutumnPromise<RedeemReferralCodeResult>;
    };
    products: {
        list: () => AutumnPromise<{
            list: Product[];
        }>;
    };
}

interface ErrorResponse {
    message: string;
    code: string;
}
type OmitCustomerType = "id" | "name" | "email" | "fingerprint" | "customer_id";
interface NextAutumnClientConfig {
    encryptedCustomerId?: string;
    customerData?: CustomerData;
    defaultReturnUrl?: string;
}
declare class NextAutumnClient extends AutumnClient {
    private readonly encryptedCustomerId?;
    constructor({ encryptedCustomerId, customerData, defaultReturnUrl }: NextAutumnClientConfig);
    createCustomer(params: Omit<CreateCustomerParams, "id" | "data"> & {
        errorOnNotFound?: boolean;
    }): Promise<any>;
    getPricingTable(): Promise<any>;
    attach: (params: AttachParams) => AutumnPromise<AttachResult>;
    cancel: (params: CancelParams) => AutumnPromise<CancelResult>;
    check: (params: CheckParams) => AutumnPromise<CheckResult>;
    track: (params: TrackParams) => AutumnPromise<TrackResult>;
    openBillingPortal: (params?: OpenBillingPortalParams | undefined) => Promise<any>;
    entities: {
        create: (params: CreateEntityParams | CreateEntityParams[]) => AutumnPromise<Entity | Entity[]>;
        get: (entityId: string, params?: GetEntityParams) => AutumnPromise<Entity>;
        delete: (entityId: string) => AutumnPromise<DeleteEntityResult>;
    };
    referrals: any;
}

export { type ErrorResponse, NextAutumnClient, type NextAutumnClientConfig, type OmitCustomerType };
