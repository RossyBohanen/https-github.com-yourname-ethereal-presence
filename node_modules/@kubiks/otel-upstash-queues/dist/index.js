import { context, SpanKind, SpanStatusCode, trace, } from "@opentelemetry/api";
const DEFAULT_TRACER_NAME = "@kubiks/otel-upstash-queues";
const INSTRUMENTED_FLAG = Symbol("kubiksOtelUpstashQueuesInstrumented");
// Semantic attribute constants
export const SEMATTRS_MESSAGING_SYSTEM = "messaging.system";
export const SEMATTRS_MESSAGING_OPERATION = "messaging.operation";
export const SEMATTRS_QSTASH_RESOURCE = "qstash.resource";
export const SEMATTRS_QSTASH_TARGET = "qstash.target";
export const SEMATTRS_QSTASH_MESSAGE_ID = "qstash.message_id";
export const SEMATTRS_QSTASH_URL = "qstash.url";
export const SEMATTRS_QSTASH_METHOD = "qstash.method";
export const SEMATTRS_QSTASH_DELAY = "qstash.delay";
export const SEMATTRS_QSTASH_NOT_BEFORE = "qstash.not_before";
export const SEMATTRS_QSTASH_DEDUPLICATION_ID = "qstash.deduplication_id";
export const SEMATTRS_QSTASH_RETRIES = "qstash.retries";
export const SEMATTRS_QSTASH_CALLBACK_URL = "qstash.callback_url";
export const SEMATTRS_QSTASH_FAILURE_CALLBACK_URL = "qstash.failure_callback_url";
// Receiver-specific attributes
export const SEMATTRS_QSTASH_RETRIED = "qstash.retried";
export const SEMATTRS_QSTASH_SCHEDULE_ID = "qstash.schedule_id";
export const SEMATTRS_QSTASH_CALLER_IP = "qstash.caller_ip";
export const SEMATTRS_HTTP_STATUS_CODE = "http.status_code";
// Body/payload attributes
export const SEMATTRS_QSTASH_REQUEST_BODY = "qstash.request.body";
export const SEMATTRS_QSTASH_RESPONSE_BODY = "qstash.response.body";
function serializeBody(body, maxLength) {
    try {
        const serialized = typeof body === "string" ? body : JSON.stringify(body);
        if (serialized.length > maxLength) {
            return serialized.substring(0, maxLength) + "... (truncated)";
        }
        return serialized;
    }
    catch (error) {
        return "[Unable to serialize body]";
    }
}
function annotatePublishSpan(span, request, config) {
    // Set base attributes
    span.setAttributes({
        [SEMATTRS_MESSAGING_SYSTEM]: "qstash",
        [SEMATTRS_MESSAGING_OPERATION]: "publish",
        [SEMATTRS_QSTASH_RESOURCE]: "messages",
        [SEMATTRS_QSTASH_TARGET]: "messages.publish",
    });
    // Set URL
    if (request.url) {
        span.setAttribute(SEMATTRS_QSTASH_URL, request.url);
    }
    // Set HTTP method (default is POST)
    const method = request.method || "POST";
    span.setAttribute(SEMATTRS_QSTASH_METHOD, method);
    // Set delay if present
    if (typeof request.delay !== "undefined") {
        if (typeof request.delay === "number") {
            span.setAttribute(SEMATTRS_QSTASH_DELAY, request.delay);
        }
        else if (typeof request.delay === "string") {
            span.setAttribute(SEMATTRS_QSTASH_DELAY, request.delay);
        }
    }
    // Set notBefore if present
    if (typeof request.notBefore !== "undefined") {
        span.setAttribute(SEMATTRS_QSTASH_NOT_BEFORE, request.notBefore);
    }
    // Set deduplication ID if present
    if (request.deduplicationId) {
        span.setAttribute(SEMATTRS_QSTASH_DEDUPLICATION_ID, request.deduplicationId);
    }
    // Set retries if present
    if (typeof request.retries !== "undefined") {
        span.setAttribute(SEMATTRS_QSTASH_RETRIES, request.retries);
    }
    // Set callback URL if present
    if (request.callback) {
        span.setAttribute(SEMATTRS_QSTASH_CALLBACK_URL, request.callback);
    }
    // Set failure callback URL if present
    if (request.failureCallback) {
        span.setAttribute(SEMATTRS_QSTASH_FAILURE_CALLBACK_URL, request.failureCallback);
    }
    // Capture request body if enabled
    if (config?.captureBody && request.body !== undefined) {
        const maxLength = config.maxBodyLength ?? 1024;
        const bodyString = serializeBody(request.body, maxLength);
        span.setAttribute(SEMATTRS_QSTASH_REQUEST_BODY, bodyString);
    }
}
function annotatePublishResponse(span, response) {
    if (response && typeof response === "object" && "messageId" in response && response.messageId) {
        span.setAttribute(SEMATTRS_QSTASH_MESSAGE_ID, response.messageId);
    }
}
function finalizeSpan(span, error) {
    if (error) {
        if (error instanceof Error) {
            span.recordException(error);
        }
        else {
            span.recordException(new Error(String(error)));
        }
        span.setStatus({ code: SpanStatusCode.ERROR });
    }
    else {
        span.setStatus({ code: SpanStatusCode.OK });
    }
    span.end();
}
export function instrumentUpstash(client, config) {
    // Check if already instrumented
    if (client[INSTRUMENTED_FLAG]) {
        return client;
    }
    const tracer = trace.getTracer(DEFAULT_TRACER_NAME);
    // Instrument publishJSON method
    const originalPublishJSON = client.publishJSON.bind(client);
    const instrumentedPublishJSON = async function instrumentedPublishJSON(request) {
        const span = tracer.startSpan("qstash.messages.publish", {
            kind: SpanKind.CLIENT,
        });
        // Annotate span with request details
        annotatePublishSpan(span, request, config);
        // Set the span as active
        const activeContext = trace.setSpan(context.active(), span);
        try {
            // Call the original method within the active context
            const response = await context.with(activeContext, () => originalPublishJSON(request));
            // Annotate with response data
            annotatePublishResponse(span, response);
            // Mark as successful
            finalizeSpan(span);
            return response;
        }
        catch (error) {
            // Mark as failed
            finalizeSpan(span, error);
            throw error;
        }
    };
    // Replace the method with our instrumented version
    client.publishJSON = instrumentedPublishJSON;
    // Mark as instrumented
    client[INSTRUMENTED_FLAG] = true;
    return client;
}
function extractQStashHeaders(request) {
    const attributes = {};
    // Extract QStash message ID
    const messageId = request.headers.get("upstash-message-id");
    if (messageId) {
        attributes[SEMATTRS_QSTASH_MESSAGE_ID] = messageId;
    }
    // Extract retry count
    const retried = request.headers.get("upstash-retried");
    if (retried) {
        const retriedNum = parseInt(retried, 10);
        if (!isNaN(retriedNum)) {
            attributes[SEMATTRS_QSTASH_RETRIED] = retriedNum;
        }
    }
    // Extract schedule ID if present
    const scheduleId = request.headers.get("upstash-schedule-id");
    if (scheduleId) {
        attributes[SEMATTRS_QSTASH_SCHEDULE_ID] = scheduleId;
    }
    // Extract caller IP
    const callerIp = request.headers.get("upstash-caller-ip");
    if (callerIp) {
        attributes[SEMATTRS_QSTASH_CALLER_IP] = callerIp;
    }
    return attributes;
}
export function instrumentConsumer(handler, config) {
    const tracer = trace.getTracer(DEFAULT_TRACER_NAME);
    return async function instrumentedConsumer(request) {
        const span = tracer.startSpan("qstash.messages.receive", {
            kind: SpanKind.SERVER,
        });
        // Set base attributes
        span.setAttributes({
            [SEMATTRS_MESSAGING_SYSTEM]: "qstash",
            [SEMATTRS_MESSAGING_OPERATION]: "receive",
            [SEMATTRS_QSTASH_RESOURCE]: "messages",
            [SEMATTRS_QSTASH_TARGET]: "messages.receive",
        });
        // Extract and set QStash headers
        const qstashHeaders = extractQStashHeaders(request);
        span.setAttributes(qstashHeaders);
        // Capture request body if enabled
        if (config?.captureBody) {
            try {
                const clonedRequest = request.clone();
                const body = await clonedRequest.text();
                if (body) {
                    const maxLength = config.maxBodyLength ?? 1024;
                    const bodyString = serializeBody(body, maxLength);
                    span.setAttribute(SEMATTRS_QSTASH_REQUEST_BODY, bodyString);
                }
            }
            catch (error) {
                // Ignore errors when capturing request body
            }
        }
        // Set the span as active
        const activeContext = trace.setSpan(context.active(), span);
        try {
            // Call the handler within the active context
            const response = await context.with(activeContext, () => handler(request));
            // Capture response status
            span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, response.status);
            // Capture response body if enabled
            if (config?.captureBody) {
                try {
                    const clonedResponse = response.clone();
                    const responseBody = await clonedResponse.text();
                    if (responseBody) {
                        const maxLength = config.maxBodyLength ?? 1024;
                        const bodyString = serializeBody(responseBody, maxLength);
                        span.setAttribute(SEMATTRS_QSTASH_RESPONSE_BODY, bodyString);
                    }
                }
                catch (error) {
                    // Ignore errors when capturing response body
                }
            }
            // Mark as successful if status is 2xx
            if (response.status >= 200 && response.status < 300) {
                finalizeSpan(span);
            }
            else {
                finalizeSpan(span, new Error(`Handler returned status ${response.status}`));
            }
            return response;
        }
        catch (error) {
            // Mark as failed
            finalizeSpan(span, error);
            throw error;
        }
    };
}
//# sourceMappingURL=index.js.map